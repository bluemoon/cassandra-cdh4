<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>CQL</title></head><body><p><link rel="StyleSheet" href="CQL.css" type="text/css" media="screen"></p><h1 id="CassandraQueryLanguageCQLv3.0.0">Cassandra Query Language (CQL) v3.0.0</h1><span id="tableOfContents"><ol style="list-style: none;"><li><a href="CQL.html#CassandraQueryLanguageCQLv3.0.0">Cassandra Query Language (CQL) v3.0.0</a><ol style="list-style: none;"><li><a href="CQL.html#CQLSyntax">CQL Syntax</a><ol style="list-style: none;"><li><a href="CQL.html#Preamble">Preamble</a></li><li><a href="CQL.html#Conventions">Conventions</a></li><li><a href="CQL.html#identifiers">Identifiers and keywords</a></li><li><a href="CQL.html#constants">Constants</a></li><li><a href="CQL.html#Comments">Comments</a></li><li><a href="CQL.html#statements">Statements</a></li><li><a href="CQL.html#preparedStatement">Prepared Statement</a></li></ol></li><li><a href="CQL.html#dataDefinition">Data Definition</a><ol style="list-style: none;"><li><a href="CQL.html#createKeyspaceStmt">CREATE KEYSPACE</a></li><li><a href="CQL.html#useStmt">USE</a></li><li><a href="CQL.html#alterKeyspaceStmt">ALTER KEYSPACE</a></li><li><a href="CQL.html#dropKeyspaceStmt">DROP KEYSPACE</a></li><li><a href="CQL.html#createTableStmt">CREATE TABLE</a></li><li><a href="CQL.html#alterTableStmt">ALTER TABLE</a></li><li><a href="CQL.html#dropTableStmt">DROP TABLE</a></li><li><a href="CQL.html#truncateStmt">TRUNCATE</a></li><li><a href="CQL.html#createIndexStmt">CREATE INDEX</a></li><li><a href="CQL.html#dropIndexStmt">DROP INDEX</a></li></ol></li><li><a href="CQL.html#dataManipulation">Data Manipulation</a><ol style="list-style: none;"><li><a href="CQL.html#insertStmt">INSERT</a></li><li><a href="CQL.html#updateStmt">UPDATE</a></li><li><a href="CQL.html#deleteStmt">DELETE</a></li><li><a href="CQL.html#batchStmt">BATCH</a></li></ol></li><li><a href="CQL.html#queries">Queries</a><ol style="list-style: none;"><li><a href="CQL.html#selectStmt">SELECT</a></li></ol></li><li><a href="CQL.html#types">Data Types</a><ol style="list-style: none;"><li><a href="CQL.html#usingdates">Working with dates</a></li><li><a href="CQL.html#counters">Counters</a></li><li><a href="CQL.html#collections">Working with collections</a></li></ol></li><li><a href="CQL.html#appendixA">Appendix A: CQL Keywords</a></li><li><a href="CQL.html#Versioning">Versioning</a></li><li><a href="CQL.html#Changes">Changes</a></li></ol></li></ol></span><h2 id="CQLSyntax">CQL Syntax</h2><h3 id="Preamble">Preamble</h3><p>This document describes the Cassandra Query Language (CQL) version 3. CQL v3 is not backward compatible with CQL v2 and differs from it in numerous ways.</p><p>CQL v3 offers a model very close to SQL in the sense that data is put in <em>tables</em> containing <em>rows</em> of <em>columns</em>. For that reason, when used in this document, these terms (tables, rows and columns) have the same definition than they have in SQL. But please note that as such, they do <strong>not</strong> refer to the concept of rows and columns found in the internal implementation of Cassandra and in the thrift and CQL v2 API.</p><h3 id="Conventions">Conventions</h3><p>To aid in specifying the CQL syntax, we will use the following conventions in this document:</p><ul><li>Language rules will be given in a <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> -like notation:</li></ul><pre class="syntax"><pre>&lt;start> ::= TERMINAL &lt;non-terminal1> &lt;non-terminal1>
</pre></pre><ul><li>Nonterminal symbols will have <code>&lt;angle brackets></code>.</li><li>As additional shortcut notations to BNF, we&#8217;ll use traditional regular expression&#8217;s symbols (<code>?</code>, <code>+</code> and <code>*</code>) to signify that a given symbol is optional and/or can be repeated. We&#8217;ll also allow parentheses to group symbols and the <code>[&lt;characters>]</code> notation to represent any one of <code>&lt;characters></code>.</li><li>The grammar is provided for documentation purposes and leave some minor details out. For instance, the last column definition in a <code>CREATE TABLE</code> statement is optional but supported if present even though the provided grammar in this document suggest it is not supported. </li><li>Sample code will be provided in a code block:</li></ul><pre class="sample"><pre>SELECT sample_usage FROM cql;
</pre></pre><ul><li>References to keywords or pieces of CQL code in running text will be shown in a <code>fixed-width font</code>.</li></ul><h3 id="identifiers">Identifiers and keywords</h3><p>The CQL language uses <em>identifiers</em> (or <em>names</em>) to identify tables, columns and other objects. An identifier is a token matching the regular expression <code lang="a-zA-Z">[a-zA-Z0-9_]</code><code>*</code>.</p><p>A number of such identifiers, like <code>SELECT</code> or <code>WITH</code>, are <em>keywords</em>. They have a fixed meaning for the language and most are reserved. The list of those keywords can be found in <a href="#appendixA">Appendix A</a>.</p><p>Identifiers and (unquoted) keywords are case insensitive. Thus <code>SELECT</code> is the same than <code>select</code> or <code>sElEcT</code>, and <code>myId</code> is the same than <code>myid</code> or <code>MYID</code> for instance. A convention often used (in particular by the samples of this documentation) is to use upper case for keywords and lower case for other identifiers.</p><p>There is a second kind of identifiers called <em>quoted identifiers</em> defined by enclosing an arbitrary sequence of characters in double-quotes(<code>"</code>). Quoted identifiers are never keywords. Thus <code>"select"</code> is not a reserved keyword and can be used to refer to a column, while <code>select</code> would raise a parse error. Also, contrarily to unquoted identifiers and keywords, quoted identifiers are case sensitive (<code>"My Quoted Id"</code> is <em>different</em> from <code>"my quoted id"</code>). A fully lowercase quoted identifier that matches <code lang="a-zA-Z">[a-zA-Z0-9_]</code><code>*</code> is equivalent to the unquoted identifier obtained by removing the double-quote (so <code>"myid"</code> is equivalent to <code>myid</code> and to <code>myId</code> but different from <code>"myId"</code>). Inside a quoted identifier, the double-quote character can be repeated to escape it, so <code>"foo "" bar"</code> is a valid identifier.</p><h3 id="constants">Constants</h3><p>CQL defines 4 kinds of <em>implicitly-typed constants</em>: strings, numbers, uuids and booleans:</p><ul><li>A string constant is an arbitrary sequence of characters characters enclosed by single-quote(<code>'</code>). One can include a single-quote in a string by repeating it, e.g. <code>'It''s raining today'</code>. Those are not to be confused with quoted identifiers that use double-quotes.</li><li>Numeric constants are either integer constant defined by <code>-?[0-9]+</code> or a float constant defined by <code>-?[0-9]+.[0-9]*</code>.</li><li>A <a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a> constant is defined by <code>hex{8}-hex{4}-hex{4}-hex{4}-hex{12}</code> where <code>hex</code> is an hexadecimal character, e.g. <code>[0-9a-fA-F]</code> and <code>{4}</code> is the number of such characters.</li><li>A boolean constant is either <code>true</code> or <code>false</code> up to case-insensitivity (i.e. <code>True</code> is a valid boolean constant).</li></ul><h3 id="Comments">Comments</h3><p>A comment in CQL is a line beginning by either double dashes (<code>--</code>) or double slash (<code>//</code>).</p><pre class="sample"><pre>-- This is a comment
// This is a comment too
</pre></pre><h3 id="statements">Statements</h3><p>CQL consists of statements. As in SQL, these statements can be divided in 3 categories:</p><ul><li>Data definition statements, that allow to set and change the way data is stored.</li><li>Data manipulation statements, that allow to change data</li><li>Queries, to look up data</li></ul><p>All statements end with a semicolon (<code>;</code>) but that semicolon can be omitted when dealing with a single statement. The supported statements are described in the following sections. When describing the grammar of said statements, we will reuse the non-terminal symbols defined below:</p><pre class="syntax"><pre>&lt;identifier> ::= any quoted or unquoted identifier, excluding reserved keywords
 &lt;tablename> ::= (&lt;identifier> '.')? &lt;identifier>

    &lt;string> ::= a string constant
   &lt;integer> ::= an integer constant
     &lt;float> ::= a float constant
    &lt;number> ::= &lt;integer> | &lt;float>
      &lt;uuid> ::= a uuid constant
   &lt;boolean> ::= a boolean constant

  &lt;final-term> ::= &lt;string>
                 | &lt;number>
                 | &lt;uuid>
                 | &lt;boolean>
        &lt;term> ::= &lt;final-term>
                 | '?'
    &lt;int-term> ::= &lt;integer>
                 | '?'

  &lt;collection-literal> ::= &lt;map-literal>
                         | &lt;set-literal>
                         | &lt;list-literal>
         &lt;map-literal> ::= '{' ( &lt;final-term> ':' &lt;final-term> ( ',' &lt;final-term> ':' &lt;final-term> )* )? '}'
         &lt;set-literal> ::= '{' ( &lt;final-term> ( ',' &lt;final-term> )* )? '}'
        &lt;list-literal> ::= '[' ( &lt;final-term> ( ',' &lt;final-term> )* )? ']'

  &lt;properties> ::= &lt;property> (AND &lt;property>)*
    &lt;property> ::= &lt;identifier> '=' ( &lt;value> | &lt;map-literal> )
       &lt;value> ::= &lt;identifier> | &lt;string> | &lt;number> | &lt;boolean>
</pre></pre><p><br/>The question mark (<code>?</code>) in the syntax above is a bind variables for <a href="#preparedStatement">prepared statements</a>.</p><p>The <code>&lt;properties></code> production is use by statement that create and alter keyspaces and tables. Each <code>&lt;property></code> is either a <em>simple</em> one, in which case it just has a value, or a <em>map</em> one, in which case it&#8217;s value is a map grouping sub-options. The following will refer to one or the other as the <em>kind</em> (<em>simple</em> or <em>map</em>) of the property.</p><p>A <code>&lt;tablename></code> will be used to identify a table. This is an identifier representing the table name that can be preceded by a keyspace name. The keyspace name, if provided, allow to identify a table in another keyspace than the currently active one (the currently active keyspace is set through the <a href="#useStmt"><tt>USE</tt></a> statement).</p><h3 id="preparedStatement">Prepared Statement</h3><p>CQL supports <em>prepared statements</em>. Prepared statement is an optimization that allows to parse a query only once but execute it multiple times with differente concrete values.</p><p>In a statement, each time a column value is expected (in the data manipulation and query statements), a bind variable marker (denoted by a <code>?</code> symbol) can be used instead. A statement with bind variables must then be <em>prepared</em>. Once it has been prepared, it can executed by providing concrete values for the bind variables (values for bind variables must be provided in the order the bind variables are defined in the query string). The exact procedure to prepare a statement and execute a prepared statement depends on the CQL driver used and is beyond the scope of this document.</p><h2 id="dataDefinition">Data Definition</h2><h3 id="createKeyspaceStmt">CREATE KEYSPACE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-keyspace-stmt> ::= CREATE KEYSPACE &lt;identifier> WITH &lt;properties>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE KEYSPACE Excelsior
           WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};

CREATE KEYSPACE Excalibur
           WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1' : 1, 'DC2' : 3}
            AND durable_writes = false;
</pre></pre><p><br/>The <code>CREATE KEYSPACE</code> statement creates a new top-level <em>keyspace</em>. A keyspace is a namespace that defines a replication strategy and some options for a set of tables. Valid keyspaces names are identifiers composed exclusively of alphanumerical characters and whose length is lesser or equal to 32. Note that as identifiers, keyspace names are case insensitive: use a quoted identifier for case sensitive keyspace names.</p><p>The supported <code>&lt;properties></code> for <code>CREATE KEYSPACE</code> are:</p><table><tr><th>name          </th><th>kind   </th><th>mandatory </th><th>default </th><th>description</th></tr><tr><td><code>replication</code>    </td><td><em>map</em>    </td><td>yes         </td><td>          </td><td>The replication strategy and options to use for the keyspace. </td></tr><tr><td><code>durable_writes</code> </td><td><em>simple</em> </td><td>no          </td><td>true      </td><td>Whether to use the commit log for updates on this keyspace (disable this option at your own risk!). </td></tr></table><p>The <code>replication</code> <code>&lt;property></code> is mandatory. It must at least contains the <code>'class'</code> sub-option which defines the replication strategy class to use. The rest of the sub-options depends on that replication strategy class. By default, Cassandra support the following <code>'class'</code>:</p><ul><li><code>'SimpleStrategy'</code>: A simple strategy that defines a simple replication factor for the whole cluster. The only sub-options supported is <code>'replication_factor'</code> to define that replication factor and is mandatory.</li><li><code>'NetworkTopologyStrategy'</code>: A replication strategy that allows to set the replication factor independently for each data-center. The rest of the sub-options are key-value pairs where each time the key is the name of a datacenter and the value the replication factor for that data-center.</li><li><code>'OldNetworkTopologyStrategy'</code>: A legacy replication strategy. You should avoid this strategy for new keyspaces and prefer <code>'NetworkTopologyStrategy'</code>.</li></ul><h3 id="useStmt">USE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;use-stmt> ::= USE &lt;identifier>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>USE myApp;
</pre></pre><p>The <code>USE</code> statement takes an existing keyspace name as argument and set it as the per-connection current working keyspace. All subsequent keyspace-specific actions will be performed in the context of the selected keyspace, unless <a href="#statements">otherwise specified</a>, until another USE statement is issued or the connection terminates.</p><h3 id="alterKeyspaceStmt">ALTER KEYSPACE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-keyspace-stmt> ::= ALTER KEYSPACE &lt;identifier> WITH &lt;properties>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>ALTER KEYSPACE Excelsior
          WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 4};

</pre></pre><p><br/>The <code>ALTER KEYSPACE</code> statement alter the properties of an existing keyspace. The supported <code>&lt;properties></code> are the same that for the <a href="#createKeyspaceStmt"><code>CREATE TABLE</code></a> statement.</p><h3 id="dropKeyspaceStmt">DROP KEYSPACE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-keyspace-stmt> ::= DROP KEYSPACE &lt;identifier>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>DROP KEYSPACE myApp;
</pre></pre><p>A <code>DROP KEYSPACE</code> statement results in the immediate, irreversible removal of an existing keyspace, including all column families in it, and all data contained in those column families.</p><h3 id="createTableStmt">CREATE TABLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-table-stmt> ::= CREATE (TABLE | COLUMNFAMILY) &lt;tablename>
                          '(' &lt;definition> ( ',' &lt;definition> )* ')'
                          ( WITH &lt;option> ( AND &lt;option>)* )?

&lt;column-definition> ::= &lt;identifier> &lt;type> ( PRIMARY KEY )?
                      | PRIMARY KEY '(' &lt;partition-key> ( ',' &lt;identifier> )* ')'

&lt;partition-key> ::= &lt;identifier>
                  | '(' &lt;identifier> ( ',' &lt;identifier> )* ')'

&lt;option> ::= &lt;property>
           | COMPACT STORAGE
           | CLUSTERING ORDER
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE TABLE monkeySpecies (
    species text PRIMARY KEY,
    common_name text,
    population varint,
    average_size int
) WITH comment='Important biological records'
   AND read_repair_chance = 1.0;

CREATE TABLE timeline (
    userid uuid,
    posted_month int,
    posted_time uuid,
    body text,
    posted_by text,
    PRIMARY KEY (userid, posted_month, posted_time)
) WITH compaction_strategy = { 'class' : 'LeveledCompactionStrategy' };
</pre></pre><p><br/>The <code>CREATE TABLE</code> statement creates a new table. Each such table is a set of <em>rows</em> (usually representing related entities) for which it defines a number of properties. A table is defined by a <a href="#createTableName">name</a>, it defines the <a href="#createTableColumn"><it>columns</it></a> composing rows of the table and have a number of <a href="#createTableOptions">options</a>. Note that the <code>CREATE COLUMNFAMILY</code> syntax is supported as an alias for <code>CREATE TABLE</code> (for historical reasons).</p><h4 id="createTableName"><code>&lt;tablename></code></h4><p>Valid table names are the same than valid <a href="#createKeyspaceStmt">keyspace names</a> (up to 32 characters long alphanumerical identifiers). If the table name is provided alone, the table is created within the current keyspace (see <a href="#useStmt"><tt>USE</tt></a>), but if it is prefixed by an existing keyspace name (see <a href="#statements"><code>&lt;tablename></code></a> grammar), it is created in the specified keyspace (but does <strong>not</strong> change the current keyspace).</p><h4 id="createTableColumn"><code>&lt;column-definition></code></h4><p>A <code>CREATE TABLE</code> statement defines the columns that rows of the table can have. A <em>column</em> is defined by its name (an identifier) and its type (see the <a href="#types">data types</a> section for more details on allowed types and their properties).</p><p>Within a table, a row is uniquely identified by its <code>PRIMARY KEY</code> (or more simply the key), and hence all table definitions <strong>must</strong> define a PRIMARY KEY (and only one). A <code>PRIMARY KEY</code> is composed of one or more of the columns defined in the table. If the <code>PRIMARY KEY</code> is only one column, this can be specified directly after the column definition. Otherwise, it must be specified by following <code>PRIMARY KEY</code> by the comma-separated list of column names composing the key within parenthesis. Note that:</p><pre class="sample"><pre>CREATE TABLE t (
    k int PRIMARY KEY,
    other text
)
</pre></pre><p>is equivalent to</p><pre class="sample"><pre>CREATE TABLE t (
    k int,
    other text,
    PRIMARY KEY (k)
)
</pre></pre><p>Moreover, a table must define at least one column that is not part of the PRIMARY KEY as a row exists in Cassandra only if it contains at least one value for one such column.</p><h4 id="createTablepartitionClustering">Partition key and clustering</h4><p>In CQL, the order in which columns are defined for the <code>PRIMARY KEY</code> matters. The first column of the key is called the <i>partition key</i>. It has the property that all the rows sharing the same partition key (even across table in fact) are stored on the same physical node. Also, insertion/update/deletion on rows sharing the same partition key for a given table are performed <i>atomically</i> and in <i>isolation</i>. Note that it is possible to have a composite partition key, i.e. a partition key formed of multiple columns, using an extra set of parentheses to define which columns forms the partition key.</p><p>The remaining columns of the <code>PRIMARY KEY</code> definition, if any, are called <i>clustering keys</i>. On a given physical node, rows for a given partition key are stored in the order induced by the clustering keys, making the retrieval of rows in that clustering order particularly efficient (see <a href="#selectStmt"><tt>SELECT</tt></a>).</p><h4 id="createTableOptions"><code>&lt;option></code></h4><p>The <code>CREATE TABLE</code> statement supports a number of options that controls the configuration of a new table. These options can be specified after the <code>WITH</code> keyword.</p><p>The first of these option is <code>COMPACT STORAGE</code>. This option is meanly targeted towards backward compatibility with some table definition created before CQL3.  But it also provides a slightly more compact layout of data on disk, though at the price of flexibility and extensibility, and for that reason is not recommended unless for the backward compatibility reason. The restriction for table with <code>COMPACT STORAGE</code> is that they support one and only one column outside of the ones part of the <code>PRIMARY KEY</code>. It also follows that columns cannot be added nor removed after creation. A table with <code>COMPACT STORAGE</code> must also define at least one <a href="createTablepartitionClustering">clustering key</a>.</p><p>Another option is <code>CLUSTERING ORDER</code>. It allows to define the ordering of rows on disk. It takes the list of the clustering key names with, for each of them, the on-disk order (Ascending or descending). Note that this option affects <a href="#selectOrderBy">what <code>ORDER BY</code> are allowed during <code>SELECT</code></a>.</p><p>Table creation supports the following other <code>&lt;property></code>:</p><table><tr><th>option                    </th><th>kind   </th><th>default   </th><th>description</th></tr><tr><td><code>comment</code>                    </td><td><em>simple</em> </td><td>none        </td><td>A free-form, human-readable comment.</td></tr><tr><td><code>read_repair_chance</code>         </td><td><em>simple</em> </td><td>0.1         </td><td>The probability with which to query extra nodes (e.g. more nodes than required by the consistency level) for the purpose of read repairs.</td></tr><tr><td><code>dclocal_read_repair_chance</code> </td><td><em>simple</em> </td><td>0           </td><td>The probability with which to query extra nodes (e.g. more nodes than required by the consistency level) belonging to the same data center than the read coordinator for the purpose of read repairs.</td></tr><tr><td><code>gc_grace_seconds</code>           </td><td><em>simple</em> </td><td>864000      </td><td>Time to wait before garbage collecting tombstones (deletion markers).</td></tr><tr><td><code>bloom_filter_fp_chance</code>     </td><td><em>simple</em> </td><td>0.00075     </td><td>The target probability of false positive of the sstable bloom filters. Said bloom filters will be sized to provide the provided probability (thus lowering this value impact the size of bloom filters in-memory and on-disk)</td></tr><tr><td><code>compaction</code>                 </td><td><em>map</em>    </td><td><em>see below</em> </td><td>The compaction otpions to use, see below.</td></tr><tr><td><code>compression</code>                </td><td><em>map</em>    </td><td><em>see below</em> </td><td>Compression options, see below. </td></tr><tr><td><code>replicate_on_write</code>         </td><td><em>simple</em> </td><td>true        </td><td>Whether to replicate data on write. This can only be set to false for tables with counters values. Disabling this is dangerous and can result in random lose of counters, don&#8217;t disable unless you are sure to know what you are doing</td></tr><tr><td><code>caching</code>                    </td><td><em>simple</em> </td><td>keys_only   </td><td>Whether to cache keys (&#8220;key cache&#8221;) and/or rows (&#8220;row cache&#8221;) for this table. Valid values are: <code>all</code>, <code>keys_only</code>, <code>rows_only</code> and <code>none</code>. </td></tr></table><h4 id="compactionOptions"><code>compaction</code> options</h4><p>The <code>compaction</code> property must at least define the <code>'class'</code> sub-option, that defines the compaction strategy class to use. The default supported class are <code>'SizeTieredCompactionStrategy'</code> and <code>'LeveledCompactionStrategy'</code>. Custom strategy can be provided by specifying the full class name as a <a href="#constants">string constant</a>. The rest of the sub-options depends on the chosen class. The sub-options supported by the default classes are:</p><table><tr><th>option                        </th><th>supported compaction strategy </th><th>default </th><th>description </th></tr><tr><td><code>tombstone_threshold</code>           </td><td><em>all</em>                           </td><td>0.2       </td><td>A ratio such that if a sstable has more than this ratio of gcable tombstones over all contained columns, the sstable will be compacted (with no other sstables) for the purpose of purging those tombstones. </td></tr><tr><td><code>tombstone_compaction_interval</code> </td><td><em>all</em>                           </td><td>1 day     </td><td>The mininum time to wait after an sstable creation time before considering it for &#8220;tombstone compaction&#8221;, where &#8220;tombstone compaction&#8221; is the compaction triggered if the sstable has more gcable tombstones than <code>tombstone_threshold</code>. </td></tr><tr><td><code>min_sstable_size</code>              </td><td>SizeTieredCompactionStrategy    </td><td>50MB      </td><td>The size tiered strategy groups SSTables to compact in buckets. A bucket groups SSTables that differs from less than 50% in size.  However, for small sizes, this would result in a bucketing that is too fine grained. <code>min_sstable_size</code> defines a size threshold (in bytes) below which all SSTables belong to one unique bucket</td></tr><tr><td><code>min_compaction_threshold</code>      </td><td>SizeTieredCompactionStrategy    </td><td>4         </td><td>Minimum number of SSTables needed to start a minor compaction.</td></tr><tr><td><code>max_compaction_threshold</code>      </td><td>SizeTieredCompactionStrategy    </td><td>32        </td><td>Maximum number of SSTables processed by one minor compaction.</td></tr><tr><td><code>bucket_low</code>                    </td><td>SizeTieredCompactionStrategy    </td><td>0.5       </td><td>Size tiered consider sstables to be within the same bucket if their size is within [average_size * <code>bucket_low</code>, average_size * <code>bucket_high</code> ] (i.e the default groups sstable whose sizes diverges by at most 50%)</td></tr><tr><td><code>bucket_high</code>                   </td><td>SizeTieredCompactionStrategy    </td><td>1.5       </td><td>Size tiered consider sstables to be within the same bucket if their size is within [average_size * <code>bucket_low</code>, average_size * <code>bucket_high</code> ] (i.e the default groups sstable whose sizes diverges by at most 50%).</td></tr><tr><td><code>sstable_size_in_mb</code>            </td><td>LeveledCompactionStrategy       </td><td>5MB       </td><td>The target size (in MB) for sstables in the leveled strategy. Note that while sstable sizes should stay less or equal to <code>sstable_size_in_mb</code>, it is possible to exceptionally have a larger sstable as during compaction, data for a given partition key are never split into 2 sstables</td></tr></table><p>For the <code>compression</code> property, the following default sub-options are available:</p><table><tr><th>option              </th><th>default        </th><th>description </th></tr><tr><td><code>sstable_compression</code> </td><td>SnappyCompressor </td><td>The compression algorithm to use. Default compressor are: SnappyCompressor and DeflateCompressor. Use an empty string (<code>''</code>) to disable compression. Custom compressor can be provided by specifying the full class name as a <a href="#constants">string constant</a>.</td></tr><tr><td><code>chunk_length_kb</code>     </td><td>64KB             </td><td>On disk SSTables are compressed by block (to allow random reads). This defines the size (in KB) of said block. Bigger values may improve the compression rate, but increases the minimum size of data to be read from disk for a read </td></tr><tr><td><code>crc_check_chance</code>    </td><td>1.0              </td><td>When compression is enabled, each compressed block includes a checksum of that block for the purpose of detecting disk bitrot and avoiding the propagation of corruption to other replica. This option defines the probability with which those checksums are checked during read. By default they are always checked. Set to 0 to disable checksum checking and to 0.5 for instance to check them every other read</td></tr></table><h4 id="Otherconsiderations">Other considerations:</h4><ul><li>When <a href="#insertStmt/&quot;updating&quot;:#updateStmt">inserting</a> a given row, not all columns needs to be defined (except for those part of the key), and missing columns occupy no space on disk. Furthermore, adding new columns (see &lt;a href=#alterStmt><tt>ALTER TABLE</tt></a>) is a constant time operation. There is thus no need to try to anticipate future usage (or to cry when you haven&#8217;t) when creating a table.</li></ul><h3 id="alterTableStmt">ALTER TABLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;alter-table-stmt> ::= ALTER (TABLE | COLUMNFAMILY) &lt;tablename> &lt;instruction>

&lt;instruction> ::= ALTER &lt;identifier> TYPE &lt;type>
                | ADD   &lt;identifier> &lt;type>
                | DROP  &lt;identifier>
                | WITH  &lt;option> ( AND &lt;option> )*
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>ALTER TABLE addamsFamily
ALTER lastKnownLocation TYPE uuid;

ALTER TABLE addamsFamily
ADD gravesite varchar;

ALTER TABLE addamsFamily
DROP gender;

ALTER TABLE addamsFamily
WITH comment = 'A most excellent and useful column family'
 AND read_repair_chance = 0.2;
</pre></pre><p><br/>The <code>ALTER</code> statement is used to manipulate table definitions. It allows to add new columns, drop existing ones, change the type of existing columns, or update the table options. As for table creation, <code>ALTER COLUMNFAMILY</code> is allowed as an alias for <code>ALTER TABLE</code>.</p><p>The <code>&lt;tablename></code> is the table name optionally preceded by the keyspace name.  The <code>&lt;instruction></code> defines the alteration to perform:</p><ul><li><code>ALTER</code>: Update the type of a given defined column. Note that the type of the <a href="#createTablepartitionClustering">clustering keys</a> cannot be modified as it induces the on-disk ordering of rows. Columns on which a <a href="#createIndexStmt">secondary index</a> is defined have the same restriction. Other columns are free from those restrictions (no validation of existing data is performed), but it is usually a bad idea to change the type to a non-compatible one, unless no data have been inserted for that column yet, as this could confuse CQL drivers/tools.</li><li><code>ADD</code>: Adds a new column to the table. The <code>&lt;identifier></code> for the new column must not conflict with an existing column. Moreover, columns cannot be added to tables defined with the <code>COMPACT STORAGE</code> option.</li><li><code>DROP</code>: <code>TODO</code> (pending <a href="https://issues.apache.org/jira/browse/CASSANDRA-3919">#3919</a>)</li><li><code>WITH</code>: Allows to update the options of the table. The <a href="#createTableOptions">supported <code>&lt;option></code></a> (and syntax) are the same as for the <code>CREATE TABLE</code> statement except that <code>COMPACT STORAGE</code> is not supported. Note that setting any <code>compaction</code> sub-options has the effect of erasing all previous <code>compaction</code> options, so you  need to re-specify all the sub-options if you want to keep them. The same note applies to the set of <code>compression</code> sub-options.</li></ul><h3 id="dropTableStmt">DROP TABLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-table-stmt> ::= DROP TABLE &lt;tablename>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>DROP TABLE worldSeriesAttendees;
</pre></pre><p>The <code>DROP TABLE</code> statement results in the immediate, irreversible removal of a table, including all data contained in it. As for table creation, <code>DROP COLUMNFAMILY</code> is allowed as an alias for <code>DROP TABLE</code>.</p><h3 id="truncateStmt">TRUNCATE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;truncate-stmt> ::= TRUNCATE &lt;tablename>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>TRUNCATE superImportantData;
</pre></pre><p>The <code>TRUNCATE</code> statement permanently removes all data from a table.</p><h3 id="createIndexStmt">CREATE INDEX</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-index-stmt> ::= CREATE INDEX &lt;identifier>? ON &lt;tablename> '(' &lt;identifier> ')'
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>CREATE INDEX userIndex ON NerdMovies (user);
CREATE INDEX ON Mutants (abilityId);
</pre></pre><p>The <code>CREATE INDEX</code> statement is used to create a new (automatic) secondary index for a given (existing) column in a given table. A name for the index itself can be specified before the <code>ON</code> keyword, if desired. If data already exists for the column, it will be indexed during the execution of this statement. After the index is created, new data for the column is indexed automatically at insertion time.</p><h3 id="dropIndexStmt">DROP INDEX</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-index-stmt> ::= DROP INDEX &lt;identifier>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>DROP INDEX userIndex;
</pre></pre><p>The <code>DROP INDEX</code> statement is used to drop an existing secondary index. The argument of the statement is the index name.</p><h2 id="dataManipulation">Data Manipulation</h2><h3 id="insertStmt">INSERT</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;insertStatement> ::= INSERT INTO &lt;tablename>
                             '(' &lt;identifier> ( ',' &lt;identifier> )* ')'
                      VALUES '(' &lt;term-or-literal> ( ',' &lt;term-or-literal> )* ')'
                      ( USING &lt;option> ( AND &lt;option> )* )?

&lt;term-or-literal> ::= &lt;term>
                    | &lt;collection-literal>

&lt;option> ::= TIMESTAMP &lt;integer>
           | TTL &lt;integer>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>INSERT INTO NerdMovies (movie, director, main_actor, year)
                VALUES ('Serenity', 'Joss Whedon', 'Nathan Fillion', 2005)
USING TTL 86400;
</pre></pre><p>The <code>INSERT</code> statement writes one or more columns for a given row in a table. Note that since a row is identified by its <code>PRIMARY KEY</code>, the columns that compose it must be specified. Also, since a row only exists when it contains one value for a column not part of the <code>PRIMARY KEY</code>, one such value must be specified too.</p><p>Note that unlike in SQL, <code>INSERT</code> does not check the prior existence of the row: the row is created if none existed before, and updated otherwise. Furthermore, there is no mean to know which of creation or update happened. In fact, the semantic of <code>INSERT</code> and <code>UPDATE</code> are identical.</p><p>All updates for an <code>INSERT</code> are applied atomically and in isolation.</p><p>Please refer to the <a href="#updateOptions"><code>UPDATE</code></a> section for information on the <code>&lt;option></code> available and to the <a href="#collections">collections</a> section for use of <code>&lt;collection-literal></code>. Also note that <code>INSERT</code> does not support counters, while <code>UPDATE</code> does.</p><h3 id="updateStmt">UPDATE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;update-stmt> ::= UPDATE &lt;tablename>
                  ( USING &lt;option> ( AND &lt;option> )* )?
                  SET &lt;assignment> ( ',' &lt;assignment> )*
                  WHERE &lt;where-clause>

&lt;assignment> ::= &lt;identifier> '=' &lt;term>
               | &lt;identifier> '=' &lt;identifier> ('+' | '-') (&lt;int-term> | &lt;set-literal> | &lt;list-literal>)
               | &lt;identifier> '=' &lt;identifier> '+' &lt;map-literal>
               | &lt;identifier> '[' &lt;term> ']' '=' &lt;term>

&lt;where-clause> ::= &lt;identifier> '=' &lt;term>
                 | &lt;identifier> IN '(' &lt;term> ( ',' &lt;term> )* ')'

&lt;option> ::= TIMESTAMP &lt;integer>
           | TTL &lt;integer>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>UPDATE NerdMovies USING TTL 400
SET director = 'Joss Whedon',
    main_actor = 'Nathan Fillion',
    year = 2005
WHERE movie = 'Serenity';

UPDATE UserActions SET total = total + 2 WHERE user = B70DE1D0-9908-4AE3-BE34-5573E5B09F14 AND action = 'click';
</pre></pre><p><br/>The <code>UPDATE</code> statement writes one or more columns for a given row in a table. The <code>&lt;where-clause></code> is used to select the row to update and must include all columns composing the <code>PRIMARY KEY</code>. Other columns values are specified through <code>&lt;assignment></code> after the <code>SET</code> keyword.</p><p>Note that unlike in SQL, <code>UPDATE</code> does not check the prior existence of the row: the row is created if none existed before, and updated otherwise. Furthermore, there is no mean to know which of creation or update happened. In fact, the semantic of <code>INSERT</code> and <code>UPDATE</code> are identical.</p><p>In an <code>UPDATE</code> statement, all updates within the same partition key are applied atomically and in isolation.</p><p>The <code>c = c + 3</code> form of <code>&lt;assignment></code> is used to increment/decrement counters. The identifier after the &#8216;=&#8217; sign <strong>must</strong> be the same than the one before the &#8216;=&#8217; sign (Only increment/decrement is supported on counters, not the assignment of a specific value).</p><p>The <code>id = id + &lt;collection-literal></code> and <code>id[value1] = value2</code> forms of <code>&lt;assignment></code> are for collections. Please refer to the <a href="#collections">relevant section</a> for more details.</p><h4 id="updateOptions"><code>&lt;options></code></h4><p>The <code>UPDATE</code> and <code>INSERT</code> statements allows to specify the following options for the insertion:</p><ul><li><code>TIMESTAMP</code>: sets the timestamp for the operation. If not specified, the current time of the insertion (in microseconds) is used. This is usually a suitable default.</li><li><code>TTL</code>: allows to specify an optional Time To Live (in seconds) for the inserted values. If set, the inserted values are automatically removed from the database after the specified time. Note that the TTL concerns the inserted values, not the column themselves. This means that any subsequent update of the column will also reset the TTL (to whatever TTL is specified in that update). By default, values never expire.</li></ul><h3 id="deleteStmt">DELETE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;delete-stmt> ::= DELETE ( &lt;selection> ( ',' &lt;selection> )* )?
                  FROM &lt;tablename>
                  ( USING TIMESTAMP &lt;integer>)?
                  WHERE &lt;where-clause>

&lt;selection> ::= &lt;identifier> ( '[' &lt;term> ']' )?

&lt;where-clause> ::= &lt;identifier> '=' &lt;term>
                 | &lt;identifier> IN '(' &lt;term> ( ',' &lt;term> )* ')'
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>DELETE FROM NerdMovies USING TIMESTAMP 1240003134 WHERE movie = 'Serenity';

DELETE phone FROM Users WHERE userid IN (C73DE1D3-AF08-40F3-B124-3FF3E5109F22, B70DE1D0-9908-4AE3-BE34-5573E5B09F14);
</pre></pre><p><br/>The <code>DELETE</code> statement deletes columns and rows. If column names are provided directly after the <code>DELETE</code> keyword, only those columns are deleted from the row indicated by the <code>&lt;where-clause></code> (the <code>id[value]</code> syntax in <code>&lt;selection></code> is for collection, please refer to the <a href="#collections">collection section</a> for more details).  Otherwise whole rows are removed. The <code>&lt;where-clause></code> allows to specify the key for the row(s) to delete.</p><p><code>DELETE</code> supports the <code>TIMESTAMP</code> options with the same semantic that in the <a href="#updateStmt"><code>UPDATE</code></a> statement.</p><p>In a <code>DELETE</code> statement, all deletions within the same partition key are applied atomically and in isolation.</p><h3 id="batchStmt">BATCH</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;batch-stmt> ::= BEGIN BATCH
                 ( USING &lt;option> ( AND &lt;option> )* )?
                    &lt;modification-stmt> ( ';' &lt;modification-stmt> )*
                 APPLY BATCH

&lt;modification-stmt> ::= &lt;insert-stmt>
                      | &lt;update-stmt>
                      | &lt;delete-stmt>

&lt;option> ::= TIMESTAMP &lt;integer>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>BEGIN BATCH
  INSERT INTO users (userid, password, name) VALUES ('user2', 'ch@ngem3b', 'second user');
  UPDATE users SET password = 'ps22dhds' WHERE userid = 'user3';
  INSERT INTO users (userid, password) VALUES ('user4', 'ch@ngem3c');
  DELETE name FROM users WHERE userid = 'user1';
APPLY BATCH;
</pre></pre><p>The <code>BATCH</code> statement group multiple modification statements (insertions/updates and deletions) into a single statement. It mainly serves two purposes:</p><ol><li>it saves network round-trips between the client and the server (and sometimes between the server coordinator and the replicas) when batching multiple updates.</li><li>all updates in a <code>BATCH</code> belonging to a given partition key are performed atomically and in isolation</li></ol><p>Note however that the <code>BATCH</code> statement only allows <code>UPDATE</code>, <code>INSERT</code> and <code>DELETE</code> statements and is <em>not</em> a full analogue for SQL transactions.</p><h4 id="batchOptions"><code>&lt;option></code></h4><p><code>BATCH</code> supports both the <code>TIMESTAMP</code> option, with similar semantic to the one described in the <a href="#updateOptions"><code>UPDATE</code></a> statement (the timestamp applies to all the statement inside the batch). However, if used, <code>TIMESTAMP</code> <strong>must not</strong> be used in the statements within the batch.</p><h2 id="queries">Queries</h2><h3 id="selectStmt">SELECT</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;select-stmt> ::= SELECT &lt;select-clause>
                  FROM &lt;tablename>
                  ( WHERE &lt;where-clause> )?
                  ( ORDER BY &lt;order-by> )?
                  ( LIMIT &lt;integer> )?

&lt;select-clause> ::= &lt;column-list>
                  | COUNT '(' ( '*' | '1' ) ')'

&lt;column-list> ::= &lt;selected_id> ( ',' &lt;selected_id> )*
                | '*'

&lt;selected_id> ::= &lt;identifier>
                | WRITETIME '(' &lt;identifier> ')'
                | TTL '(' &lt;identifier> ')'

&lt;where-clause> ::= &lt;relation> ( "AND" &lt;relation> )*

&lt;relation> ::= &lt;identifier> ("=" | "&lt;" | ">" | "&lt;=" | ">=") &lt;term>
             | &lt;identifier> IN '(' &lt;term> ( ',' &lt;term>)* ')'
             | TOKEN '(' &lt;identifier> ')' ("=" | "&lt;" | ">" | "&lt;=" | ">=") (&lt;term> | TOKEN '( &lt;term> ')' )

&lt;order-by> ::= &lt;ordering> ( ',' &lt;odering> )*
&lt;ordering> ::= &lt;identifer> ( ASC | DESC )?
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>SELECT name, occupation FROM users WHERE userid IN (199, 200, 207);

SELECT time, value
FROM events
WHERE event_type = 'myEvent'
  AND time > 2011-02-03
  AND time &lt;= 2012-01-01

SELECT COUNT(*) FROM users;
</pre></pre><p><br/>The <code>SELECT</code> statements reads one or more columns for one or more rows in a table. It returns a result-set of rows, where each row contains the collection of columns corresponding to the query.</p><h4 id="selectSelection"><code>&lt;select-clause></code></h4><p>The <code>&lt;select-clause></code> determines which columns needs to be queried and returned in the result-set. It consists of either the comma-separated list of column names to query, or the wildcard character (<code>*</code>) to select all the columns defined for the table.</p><p>In addition to selecting columns, the <code>WRITETIME</code> (resp. <code>TTL</code>) function allows to select the timestamp of when the column was inserted (resp. the time to live (in seconds) for the column (or null if the column has no expiration set)).</p><p>The <code>COUNT</code> keyword can be used with parenthesis enclosing <code>*</code>. If so, the query will return a single result: the number of rows matching the query. Note that <code>COUNT(1)</code> is supported as an alias.</p><h4 id="selectWhere"><code>&lt;where-clause></code></h4><p>The <code>&lt;where-clause></code> specifies which rows must be queried. It is composed of relations on the columns that are part of the <code>PRIMARY KEY</code> and/or have a <a href="#createIndexStmt">secondary index</a> defined on them.</p><p>Not all relations are allowed in a query. For instance, non-equal relations (where <code>IN</code> is considered as an equal relation) on a partition key is only supported if the partitioner for the keyspace is an ordered one. Moreover, for a given partition key, the clustering keys induce an ordering of rows and relations on them is restricted to the relations that allow to select a <strong>contiguous</strong> (for the ordering) set of rows. For instance, given</p><pre class="sample"><pre>CREATE TABLE posts (
    userid text,
    blog_title text,
    posted_at timestamp,
    entry_title text,
    content text,
    category int,
    PRIMARY KEY (userid, blog_title, posted_at)
)
</pre></pre><p>The following query is allowed:</p><pre class="sample"><pre>SELECT entry_title, content FROM posts WHERE userid='john doe' AND blog_title='John's Blog' AND posted_at >= 2012-01-01 AND posted_at &lt; 2012-01-31
</pre></pre><p>But the following one is not, as it does not select a contiguous set of rows (and we suppose no secondary indexes are set):</p><pre class="sample"><pre>// Needs a blog_title to be set to select ranges of posted_at
SELECT entry_title, content FROM posts WHERE userid='john doe' AND posted_at >= 2012-01-01 AND posted_at &lt; 2012-01-31
</pre></pre><p>When specifying relations, the <code>TOKEN</code> function can be used on the <code>PARTITION KEY</code> column to query. In that case, rows will be selected based on the token of their <code>PARTITION_KEY</code> rather than on the value (note that the token of a key depends on the partitioner in use, and that in particular the RandomPartitioner won&#8217;t yeld a meaningful order). Example:</p><pre class="sample"><pre>SELECT * FROM posts WHERE token(userid) > token('tom') AND token(userid) &lt; token('bob')
</pre></pre><h4 id="selectOrderBy"><code>&lt;order-by></code></h4><p>The <code>ORDER BY</code> option allows to select the order of the returned results. It takes as argument a list of column names along with the order for the column (<code>ASC</code> for ascendant and <code>DESC</code> for descendant, omitting the order being equivalent to <code>ASC</code>). Currently the possible orderings are limited (which depends on the table <a href="#createTableOptions"><code>CLUSTERING ORDER</code></a>):</p><ul><li>if the table has been defined without any specific <code>CLUSTERING ORDER</code>, then then allowed orderings are the order induced by the clustering key and the reverse of that one.</li><li>otherwise, the orderings allowed are the order of the <code>CLUSTERING ORDER</code> option and the reversed one.</li></ul><h4 id="selectOther">Other options</h4><p>The <code>LIMIT</code> option to a <code>SELECT</code> statement limits the number of rows returned by a query.</p><h2 id="types">Data Types</h2><p>CQL supports a rich set of native data types for columns defined in a table.  On top of those native types, users can also provide custom types (through a JAVA class extending <code>AbstractType</code> loadable by Cassandra). The syntax of types is thus:</p><pre class="syntax"><pre>&lt;type> ::= &lt;native-type>
         | &lt;collection-type>
         | &lt;string>       // Used for custom types. The fully-qualified name of a JAVA class

&lt;native-type> ::= ascii
                | bigint
                | blob
                | boolean
                | counter
                | decimal
                | double
                | float
                | inet
                | int
                | text
                | timestamp
                | timeuuid
                | uuid
                | varchar
                | varint

&lt;collection-type> ::= list '&lt;' &lt;native-type> '>'
                    | set  '&lt;' &lt;native-type> '>'
                    | map  '&lt;' &lt;native-type> ',' &lt;native-type> '>'
</pre></pre><p>Note that the native types are keywords and as such are case-insensitive. They are however not reserved ones.</p><p>The following table gives additional informations on the native data types:</p><table><tr><th>type    </th><th>description</th></tr><tr><td><code>ascii</code>    </td><td>ASCII character string</td></tr><tr><td><code>bigint</code>   </td><td>64-bit signed long</td></tr><tr><td><code>blob</code>     </td><td>Arbitrary bytes (no validation)</td></tr><tr><td><code>boolean</code>  </td><td>true or false</td></tr><tr><td><code>counter</code>  </td><td>Counter column (64-bit signed value). See <a href="#counters">Counters</a> for details</td></tr><tr><td><code>decimal</code>  </td><td>Variable-precision decimal</td></tr><tr><td><code>double</code>   </td><td>64-bit IEEE-754 floating point</td></tr><tr><td><code>float</code>    </td><td>32-bit IEEE-754 floating point</td></tr><tr><td><code>inet</code>     </td><td>An IP address. It can be either 4 bytes long (IPv4) or 16 bytes long (IPv6)</td></tr><tr><td><code>int</code>      </td><td>32-bit signed int</td></tr><tr><td><code>text</code>     </td><td>UTF8 encoded string</td></tr><tr><td><code>timestamp</code></td><td>A timestamp. See <a href="#usingdates">Working with dates</a> below for more information.</td></tr><tr><td><code>timeuuid</code> </td><td>Type 1 UUID. This is a &#8220;conflict-free&#8221; timestamp and as <code>timestamp</code>, it allows date notation: see <a href="#usingdates">Working with dates</a> below.</td></tr><tr><td><code>uuid</code>     </td><td>Type 1 or type 4 UUID</td></tr><tr><td><code>varchar</code>  </td><td>UTF8 encoded string</td></tr><tr><td><code>varint</code>   </td><td>Arbitrary-precision integer</td></tr></table><h3 id="usingdates">Working with dates</h3><p>Values of the <code>timestamp</code> type are encoded as 64-bit signed integers representing a number of milliseconds since the standard base time known as &#8220;the epoch&#8221;: January 1 1970 at 00:00:00 GMT. Values of the <code>timeuuid</code> type also include such timestamp and sort accordingly to said timestamp.</p><p>Timestamp and timeuuid types can be input in CQL as simple long integers, giving the number of milliseconds since the epoch, as defined above.</p><p>They can also be input as string literals in any of the following ISO 8601 formats, each representing the time and date Mar 2, 2011, at 04:05:00 AM, GMT.:</p><ul><li><code>2011-02-03 04:05+0000</code></li><li><code>2011-02-03 04:05:00+0000</code></li><li><code>2011-02-03T04:05+0000</code></li><li><code>2011-02-03T04:05:00+0000</code></li></ul><p>The <code>+0000</code> above is an RFC 822 4-digit time zone specification; <code>+0000</code> refers to GMT. US Pacific Standard Time is <code>-0800</code>. The time zone may be omitted if desired&#8212; the date will be interpreted as being in the time zone under which the coordinating Cassandra node is configured.</p><ul><li><code>2011-02-03 04:05</code></li><li><code>2011-02-03 04:05:00</code></li><li><code>2011-02-03T04:05</code></li><li><code>2011-02-03T04:05:00</code></li></ul><p>There are clear difficulties inherent in relying on the time zone configuration being as expected, though, so it is recommended that the time zone always be specified for timestamps when feasible.</p><p>The time of day may also be omitted, if the date is the only piece that matters:</p><ul><li><code>2011-02-03</code></li><li><code>2011-02-03+0000</code></li></ul><p>In that case, the time of day will default to 00:00:00, in the specified or default time zone.</p><h3 id="counters">Counters</h3><p>The <code>counter</code> type is used to define <em>counter columns</em>. A counter column is a column whose value is a 64-bit signed integer and on which 2 operations are supported: incrementation and decrementation (see <a href="#updateStmt"><code>UPDATE</code></a> for syntax).  Note the value of a counter cannot be set. A counter doesn&#8217;t exist until first incremented/decremented, and the first incrementation/decrementation is made as if the previous value was 0. Deletion of counter columns is supported but have some limitations (see the <a href="http://wiki.apache.org/cassandra/Counters">Cassandra Wiki</a> for more information).</p><p>The use of the counter type is limited in the following way:</p><ul><li>It cannot be used for column that is part of the <code>PRIMARY KEY</code> of a table.</li><li>A table that contains a counter can only contain counters. In other words, either all the columns of a table outside the <code>PRIMARY KEY</code> have the counter type, or none of them have it.</li></ul><h3 id="collections">Working with collections</h3><h4 id="map">Maps</h4><p>A <code>map</code> is a <a href="#types">typed</a> set of key-value pairs, where keys are unique. Furthermore, note that the map are internally sorted by their keys and will thus always be returned in that order. To create a column of type <code>map</code>, use the <code>map</code> keyword suffixed with comma-separated key and value types, enclosed in angle brackets.  For example:</p><pre class="sample"><pre>CREATE TABLE users (
    id text PRIMARY KEY,
    given text,
    surname text,
    favs map&lt;text, text>   // A map of text keys, and text values
)
</pre></pre><p>Writing <code>map</code> data is accomplished with a JSON-inspired syntax. To write a record using <code>INSERT</code>, specify the entire map as a JSON-style associative array. <em>Note: This form will always replace the entire map.</em></p><pre class="sample"><pre>// Inserting (or Updating)
INSERT INTO users (id, given, surname, favs)
           VALUES ('jsmith', 'John', 'Smith', { 'fruit' : 'apple', 'band' : 'Beatles' })
</pre></pre><p>Adding or updating key-values of a (potentially) existing map can be accomplished by subscripting the map column in an <code>UPDATE</code> statement.</p><pre class="sample"><pre>// Updating (or inserting)
UPDATE users SET favs['author'] = 'Ed Poe' WHERE id = 'jsmith'
</pre></pre><p>Deleting a map record is done with:</p><pre class="sample"><pre>DELETE favs['author'] FROM plays WHERE id = 'jsmith'
</pre></pre><h4 id="set">Sets</h4><p>A <code>set</code> is a <a href="#types">typed</a> collection of unique values. Sets are ordered by their values. To create a column of type <code>set</code>, use the <code>set</code> keyword suffixed with the value type enclosed in angle brackets.  For example:</p><pre class="sample"><pre>CREATE TABLE images (
    name text PRIMARY KEY,
    owner text,
    date timestamp,
    tags set&lt;text>
);
</pre></pre><p>Writing a <code>set</code> is accomplished by comma separating the set values, and enclosing them in curly braces.  <em>Note: An <code>INSERT</code> will always replace the entire set.</em></p><pre class="sample"><pre>INSERT INTO images (name, owner, date, tags)
            VALUES ('cat.jpg', 'jsmith', 'now', { 'kitten', 'cat', 'pet' });
</pre></pre><p>Adding and removing values of a set can be accomplished with an <code>UPDATE</code> by adding/removing new set values to an existing <code>set</code> column.</p><pre class="sample"><pre>UPDATE images SET tags = tags + { 'cute', 'cuddly' } WHERE name = 'cat.jpg';
UPDATE images SET tags = tags - { 'lame' } WHERE name = 'cat.jpg';
</pre></pre><h4 id="list">Lists</h4><p>A <code>list</code> is a <a href="#types">typed</a> collection of non-unique values where elements are ordered by there position in the list.  To create a column of type <code>list</code>, use the <code>list</code> keyword suffixed with the value type enclosed in angle brackets.  For example:</p><pre class="sample"><pre>CREATE TABLE plays (
    id text PRIMARY KEY,
    game text,
    players int,
    scores list&lt;int>
)
</pre></pre><p>Do note that as explained below, lists have some limitations and performance considerations to take into account, and it is advised to prefer <a href="#set">sets</a> over lists when this is possible.</p><p>Writing <code>list</code> data is accomplished with a JSON-style syntax.  To write a record using <code>INSERT</code>, specify the entire list as a JSON array.  <em>Note: An <code>INSERT</code> will always replace the entire list.</em></p><pre class="sample"><pre>INSERT INTO plays (id, game, players, scores)
           VALUES ('123-afde', 'quake', 3, [17, 4, 2]);
</pre></pre><p>Adding (appending or prepending) values to a list can be accomplished by adding a new JSON-style array to an existing <code>list</code> column.</p><pre class="sample"><pre>UPDATE plays SET players = 5, scores = scores + [ 14, 21 ] WHERE id = '123-afde';
UPDATE plays SET players = 5, scores = [ 12 ] + scores WHERE id = '123-afde';
</pre></pre><p>Lists also provides the following operation: setting an element by its position in the list, removing an element by its position in the list and remove all the occurrence of a given value in the list. <em>However, and contrarily to all the other collection operations, these three operations induce an internal read before the update, and will thus typically have slower performance characteristics</em>. Those operations have the following syntax:</p><pre class="sample"><pre>UPDATE plays SET scores[1] = 7 WHERE id = '123-afde';                // sets the 2nd element of scores to 7 (raises an error is scores has less than 2 elements)
DELETE scores[1] FROM plays WHERE id = '123-afde';                   // deletes the 2nd element of scores (raises an error is scores has less than 2 elements)
UPDATE plays SET scores = scores - [ 12, 21 ] WHERE id = '123-afde'; // removes all occurences of 12 and 21 from scores
</pre></pre><h2 id="appendixA">Appendix A: CQL Keywords</h2><p>CQL distinguishes between <em>reserved</em> and <em>non-reserved</em> keywords. Reserved keywords cannot be used as identifier, they are truly reserved for the language (but one can enclose a reserved keyword by double-quotes to use it as an identifier). Non-reserved keywords however only have a specific meaning in certain context but can used as identifer otherwise. The only <em>raison d'être</em> of these non-reserved keywords is convenience: some keyword are non-reserved when it was always easy for the parser to decide whether they were used as keywords or not.</p><table><tr><th>Keyword      </th><th>Reserved? </th></tr><tr><td><code>ADD</code>          </td><td>yes </td></tr><tr><td><code>ALL</code>          </td><td>yes </td></tr><tr><td><code>ALTER</code>        </td><td>yes </td></tr><tr><td><code>AND</code>          </td><td>yes </td></tr><tr><td><code>ANY</code>          </td><td>yes </td></tr><tr><td><code>APPLY</code>        </td><td>yes </td></tr><tr><td><code>ASC</code>          </td><td>yes </td></tr><tr><td><code>ASCII</code>        </td><td>no  </td></tr><tr><td><code>BATCH</code>        </td><td>yes </td></tr><tr><td><code>BEGIN</code>        </td><td>yes </td></tr><tr><td><code>BIGINT</code>       </td><td>no  </td></tr><tr><td><code>BLOB</code>         </td><td>no  </td></tr><tr><td><code>BOOLEAN</code>      </td><td>no  </td></tr><tr><td><code>BY</code>           </td><td>yes </td></tr><tr><td><code>CLUSTERING</code>   </td><td>no  </td></tr><tr><td><code>COLUMNFAMLY</code>  </td><td>yes </td></tr><tr><td><code>COMPACT</code>      </td><td>no  </td></tr><tr><td><code>CONSITENCY</code>   </td><td>no  </td></tr><tr><td><code>COUNT</code>        </td><td>no  </td></tr><tr><td><code>COUNTER</code>      </td><td>no  </td></tr><tr><td><code>CREATE</code>       </td><td>yes </td></tr><tr><td><code>DECIMAL</code>      </td><td>no  </td></tr><tr><td><code>DELETE</code>       </td><td>yes </td></tr><tr><td><code>DESC</code>         </td><td>yes </td></tr><tr><td><code>DOUBLE</code>       </td><td>no  </td></tr><tr><td><code>DROP</code>         </td><td>yes </td></tr><tr><td><code>EACH_QUORUM</code>  </td><td>yes </td></tr><tr><td><code>FLOAT</code>        </td><td>no  </td></tr><tr><td><code>FROM</code>         </td><td>yes </td></tr><tr><td><code>IN</code>           </td><td>yes </td></tr><tr><td><code>INDEX</code>        </td><td>yes </td></tr><tr><td><code>INSERT</code>       </td><td>yes </td></tr><tr><td><code>INT</code>          </td><td>no  </td></tr><tr><td><code>INTO</code>         </td><td>yes </td></tr><tr><td><code>KEY</code>          </td><td>no  </td></tr><tr><td><code>KEYSPACE</code>     </td><td>yes </td></tr><tr><td><code>LEVEL</code>        </td><td>no  </td></tr><tr><td><code>LIMIT</code>        </td><td>yes </td></tr><tr><td><code>LOCAL_QUORUM</code> </td><td>yes </td></tr><tr><td><code>ON</code>           </td><td>yes </td></tr><tr><td><code>ONE</code>          </td><td>yes </td></tr><tr><td><code>ORDER</code>        </td><td>yes </td></tr><tr><td><code>PRIMARY</code>      </td><td>yes </td></tr><tr><td><code>QUORUM</code>       </td><td>yes </td></tr><tr><td><code>SCHEMA</code>       </td><td>yes </td></tr><tr><td><code>SELECT</code>       </td><td>yes </td></tr><tr><td><code>SET</code>          </td><td>yes </td></tr><tr><td><code>STORAGE</code>      </td><td>no  </td></tr><tr><td><code>TABLE</code>        </td><td>yes </td></tr><tr><td><code>TEXT</code>         </td><td>no  </td></tr><tr><td><code>TIMESTAMP</code>    </td><td>no  </td></tr><tr><td><code>TIMEUUID</code>     </td><td>no  </td></tr><tr><td><code>THREE</code>        </td><td>yes </td></tr><tr><td><code>TOKEN</code>        </td><td>yes </td></tr><tr><td><code>TRUNCATE</code>     </td><td>yes </td></tr><tr><td><code>TTL</code>          </td><td>no  </td></tr><tr><td><code>TWO</code>          </td><td>yes </td></tr><tr><td><code>TYPE</code>         </td><td>no  </td></tr><tr><td><code>UPDATE</code>       </td><td>yes </td></tr><tr><td><code>USE</code>          </td><td>yes </td></tr><tr><td><code>USING</code>        </td><td>yes </td></tr><tr><td><code>UUID</code>         </td><td>no  </td></tr><tr><td><code>VALUES</code>       </td><td>no  </td></tr><tr><td><code>VARCHAR</code>      </td><td>no  </td></tr><tr><td><code>VARINT</code>       </td><td>no  </td></tr><tr><td><code>WHERE</code>        </td><td>yes </td></tr><tr><td><code>WITH</code>         </td><td>yes </td></tr><tr><td><code>WRITETIME</code>    </td><td>no  </td></tr></table><h2 id="Versioning">Versioning</h2><p>Versioning of the CQL language adheres to the <a href="http://semver.org">Semantic Versioning</a> guidelines. Versions take the form X.Y.Z where X, Y, and Z are integer values representing major, minor, and patch level respectively. There is no correlation between Cassandra release versions and the CQL language version.</p><table><tr><th>version</th><th>description</th></tr><tr><td>Major     </td><td>The major version <em>must</em> be bumped when backward incompatible changes are introduced. This should rarely occur.</td></tr><tr><td>Minor     </td><td>Minor version increments occur when new, but backward compatible, functionality is introduced.</td></tr><tr><td>Patch     </td><td>The patch version is incremented when bugs are fixed.</td></tr></table><h2 id="Changes">Changes</h2><pre>Tue, 06 Nov 2012 15:03:12 +0200 - Eric Evans and Sylvain Lebresne
 * Update for 1.2 changes to CQL 3

Tue, 24 Apr 2012 15:12:36 +0200 - Sylvain Lebresne
 * Rework whole doc to target CQL 3

Wed, 12 Oct 2011 16:53:00 -0500 - Paul Cannon
 * Rework whole doc, adding syntax specifics and additional explanations

Fri, 09 Sep 2011 11:43:00 -0500 - Jonathan Ellis
 * add int data type

Wed, 07 Sep 2011 09:01:00 -0500 - Jonathan Ellis
 * Updated version to 2.0; Documented row-based count()
 * Updated list of supported data types

Wed, 10 Aug 2011 11:22:00 -0500 - Eric Evans
 * Improved INSERT vs. UPDATE wording.
 * Documented counter column incr/descr.

Sat, 01 Jun 2011 15:58:00 -0600 - Pavel Yaskevich
 * Updated to support ALTER (CASSANDRA-1709)

Tue, 22 Mar 2011 18:10:28 -0700 - Eric Evans &lt;eevans@rackspace.com>
 * Initial version, 1.0.0
</pre></body></html>